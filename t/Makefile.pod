#!/usr/bin/perldoc

=pod

=head1 NAME

Makefile.pod    - documentation for project's Makefiles in POD format

=head1 SYNOPSYS

    Makefile.pod
    perldoc Makefile.pod

=head1 DESCRIPTION

This file  contains the  internal (developer) documentation  for all other
Makefile*. This is done to keep other Makefile* as simple as possible, and
just containing the user (developer) documentation.

SEE Documentation  in L<o-saft.pl|o-saft.pl> also.


=head1 ABSTRACT

While the main  Makefile  is intended for ordinary users to  perfom common
task for maintaining the project's installation, all other t/Makefile* are
intendend for development. However, as Makefile includes most t/Makefile*,
all targets for developemnt can be used there also.

Most targets for development are named:

    testarg-*
    testcmd-*
    test.*
    help.*

Where in general  testarg-*  is a target to test  one or more arguments of
a tool, and  testcmd-*  is a target to test a command of  $(SRC.pl) .
Most  test.*  targets are summary targets executing a list of the above.
All  help.*  targets are for documentation of the makefile's targets.
For more details on target names, please  see L</O-Saft:Makefile Targets> .

To get a list of all target for testing, use:

    make s-ALL.tests

For more such target, please  see L</O-Saft:Makefile Targets> .

To get a list of help target, use:

    make s-ALL.help
    make help.help
    make help.test

To get a list of makefiles and their pupose, use:

    make help.makefiles.doc


=head2 Quick Overview

This documentation here consist of following main sections:

=over

=item L</O-Saft Terms>

Most important for users (developers) is how the Makefile* work in general
and how macros, variables and targets are used.

=item L</O-Saft Makefile Syntax>

To make  maintenance and usage  of the make system  more simple (for human
users and developers),  some conventions for naming and syntax are used in
the Makefile* . This is described in this section.

=item L</GNU Make>

This section describes some GNU Make behaviours in general, and those used
in this project.

=item L</O-Saft Makefile Annotations>

The sub-headers in this section are referenced from other Makefile* .

=back


=head1 VERSION

@(#) Makefile.pod 3.7 24/07/01 08:32:10

=head1 AUTHOR

18-nov-18 Achim Hoffmann


=head1 O-Saft Terms

SEE Documentation  in L<o-saft.pl|o-saft.pl> also.


=head1 O-Saft Makefile Quick Overview

All Makefile* provide a set of targets using a well defined naming convention.

Examples (for Makefile.tcl)  which provide help (documentation)  for available
targets:

    make
    make help
    make help.test
    make help.test.tcl
    make help.test.tcl.all

Get a list of (nearly) all targets:

    make s-ALL.tests

Just get a list of all targets for a specific type:

    make e-ALL.test.tcl
    make s-ALL.test.tcl

Calling targets:

    make test.tcl
    make test.tcl.log
    make testcmd-tcl--v-host_localhost


A common set of variables and targets is provided in all Makefile*. If the
makefile is named  Makefile.Ext , following variables exist:

    HELP.test.Ext
    TEST.Ext.hosts
    ALL.test.Ext
    ALL.test.Ext.log

and following targets exist:

    help.test.Ext
    test.Ext
    test.Ext.log

Show what all targets will do (huge output):

    make testarg-make-n


=head2 O-Saft:Makefile Example Usage

To show readable (for humans) information about variables and targets from
a Makefile* itself, see:

    make -f t/Makefile.help

To get brief (mainly technical) information about the Makefile, use:

    make -f t/Makefile.cgi
    make -f t/Makefile.cgi help.test.cgi
    make                   help.test.cgi
    make -f t/Makefile.cgi targets.me
    make -f t/Makefile.cgi macros.me
    make -f t/Makefile.cgi s-ALL.test.cgi
    make -f t/Makefile.cgi p-LIST.cgi.badIP
    make -f t/Makefile.cgi m-LIST.cgi.badIPv6
    make -f t/Makefile.cgi e-LIST.cgi.badIPv6
    make -f t/Makefile.cgi s-LIST.cgi.badIPv6

(Makefile.cgi is an example, may be any other Makefile* also).


=head1 O-Saft Makefile Limitations

* Requires GNU Make > 2.0.

* Requires GNU awk (gawk)

* Requires GNU sed (for generating target  INSTALL.sh ).

*  Unfortunately some of the macros use variables of the makefile,  like
   $(O-TAB), while other macros must use the TAB character verbatim, which
   is difficult to identify by human eyes.


=head1 O-Saft Makefile Preconditions

The tools used and tested by make are called in the  $(TEST.dir) directory
(usually ./t ), but they are located in  ../ or ../usr . Some (most) tools
tools expect "includes" in  ./ ,  i.e.  o-saft.pl  itself includes private
modules from  ./lib  This may result in perl warnings like:

    "Can't locate ...".

To avoid this, following symbolic links exist in  $(TEST.dir) :

    ./t             -> .
    ./lib           -> ../lib
    ./usr           -> ../usr
    ./.o-saft.pl    -> ../.o-saft.pl
    ./docs          -> ../docs


=head1 O-Saft Makefile*

The purpose of the targets in the Makefile* --the make system-- is testing
O-Saft functionality, code quality, and performance.
The Makefile* are located in the  $(TEST.dir)  directory (usually ./t ).

The default target in each Makefile* simply prints a brief help. Note that
the default target (the very frst one) must preceed any include directive.

Most included t/Makefiles.*  contain very limited comments. The details of
their functionality is mainly described in this documentation here.


=head1 O-Saft Makefile Syntax

This section describes the syntax and other conventions used in general in
all Makefile* . NOTE: this description is independent of any functionality
of the project, it just describes the used "coding syntax" in Makefile*.

Makefile*  use mainly  GNU Make's built-in variables and targets.  None of
them are disabled explicitly.  Therefore, some behaviour may depend on the
local make configuration.

SEE L</GNU Make:automatic variables>  also.


=head2 O-Saft:Makefile General

To extract and format the texts, the targets use  GNU Make's functionality
like  $(eval ...), $(foreach ...) and $(shell).
External tools like  awk,  sed  and  tr  must be used  when information or
text are to be extracted form other Makefile*.  Each tool  and its command
arguments are defined as variable, see corresponding  EXE.*  variables.


=head2 O-Saft:Makefile Includes

All testing functionality is grouped in individual Makefile*. They are all
included by the main Makefile and organised as follows:

    Makefile
        include t/Makefile
            include t/Makefile.inc
            include t/Makefile.gen
            include t/Makefile.help
            include t/Makefile.warnings
            include t/Makefile.cipher
            include t/Makefile.cmd
            include t/Makefile.exit
            include t/Makefile.opt
            include t/Makefile.ext
            include t/Makefile.hlp
            include t/Makefile.cgi
            include t/Makefile.tcl
            include t/Makefile.etc
            include t/Makefile.dev
            include t/Makefile.mod
            include t/Makefile.php
            include t/Makefile.init
            include t/Makefile.misc
            include t/Makefile.critic
            include t/Makefile.docker
            include t/Makefile.legacy
            include t/Makefile.make

To get a list of all included Makefile* use:

    make s-ALL.includes

It is possible to use each Makefile* independently by using GNU Make's  -f
option, for example::

    make -f Makefile.help
    make -f t/Makefile
    cd t && make -f Makefile.exit

Therefore each  Makefile*  includes  t/Makefile  depending on existence of
the  _SID.test  variable.

Following Makefile* are not included and provide additional information:

    Makefile.pod
    Makefile.diffs
    Makefile.examples


=head2 O-Saft:Makefile Variable and Target Names

General rules for our macro, variable and target names in Makefile* are:

* macro names are lowercase characters - and _ only

* variable names start with uppercase characters or  _

* names consist only of characters a-zA-Z0-9_.+-

* names starting with  _  are intended for internal use

* names use well defined prefixes which are separated by  .  or  -

* names may use variable suffixes which are separated by  _

* target names use only lowercase characters and  .  and  +  and  -  and  _

Examples:

   EXE.list         = awk
   HELP_INFO       := \# Name
   _HELP-_cgi0      = ______________________________ targets testing cgi _
   HELP-testarg-cgi-host_some.tld   = test all testarr-cgi targets
   ALL.inc.type    += cgi
   ALL.help.tests  += help.test.cgi

   testarg-cgi-host_some.tld    TEST.args  += --cgi
   testarg-cgi-host_localhost:  TEST.args  += --cgi
   testarg-cgi-host_:
           @$(O-TRACE.target)
           @do something $(TEST.args) $*

   ALL.test.cgi    += testarg-cgi-host_some.tld testarg-cgi-host_localhost

   test.cgi:          $(ALL.test.cgi)

=head3 Used Pattern for Names

Most targets and variables are named with one of following prefixes:

   ALL
   EXE
   GEN
   HELP
   SRC
   LIST
   TEST
   _HELP
   _TEST
   _SID
   help
   test

The main Makefile is an exception, because it uses commonly used names for
targets.


=head2 O-Saft:Makefile Variable Values

In general no quotes  around texts in variables  are used.  However, it is
sometimes necessary to use quotes to enforce the proper evaluation of used
variables in the text (mainly in target actions).

It is prefered that the complete definition, name=value, fits in one line,
however, huge definitions are splited in multiple lines for better (human)
readability.

Sometimes Make's  'define' functions are used instead of variables, mainly
if it does not fit in one line.


=head2 O-Saft:Makefile Version String

Each Makefile defines its own unique SID as variable with a version number
as value.  This SID is used  several times verbatim.  One might argue that
the variable  _SID  or  _SID.*  should be used instead for all usages. But
it is used verbatim to ensure  that exactly this string is used and cannot
be overwritten (i.e. with an environment variable) when make is called.
If a Makefile is changed, all occurrences of the string must be changed.

The value of the _SID.* variables should be managed by the version control
system.


=head2 O-Saft:Makefile Variable, Macro names

Following internal variables in each Makefile* are used:

    _SID            - version in project's Makefile
    _SID.*          - version in included Makefile*
    _MYSELF.*       - path of the Makefile itself (in included Makefile*)

The  _SID.*  variables are used to check if sub-makefiles were included.

Following general (global) variables are set in each Makefile*:

    ALL.includes
    ALL.inc.type
    ALL.help.tests

More variables and targets are defined in following included files:

    t/Makefile
    t/Makefile.help
    t/Makefile.inc

Where  t/Makefile  may include more files.

=head3 O-Saft Makefile internal Variables

When internal variables, those staring with _, are defined, they should be
removed when possible using Make's  'undefine'.

SEE L</Make:macros> also.


=head2 O-Saft:Makefile Variables

Following names are used, which potentially conflict with make itself:

    MAKE            - make command
    MAKEFILE        - Makefile (i.g. myself, but may be redifined)

Following name prefixes are used for variables:

    SRC             - defines a source file
    GEN             - defines a generated file
    EXE             - defines tools to be used (or parameters for it)
    ALL             - defines summary variables
    LIST            - defines lists of something
    SRC.usr         - something related to the usr/ directory
    TEST            - something related to the t/ directory
    TEST.critic     - something related to perlcritic targets
    HELP            - defines texts to be used in  help  and  doc  targets
    _               - names of internal (helper) variables (they are not
                      intended to be overwritten on command-line)

Notes about some special variables:

    ALL.src         - list of all sources to be distributed
    ALL.tgz         - same as ALL.src but all sources prefixed with O-Saft/
    ALL.tst         - list of all sources used for testing the project
                      (ALL.tst instead of ALL.test used to avoid conflicts
                      with ALL.tests)
    ALL.includes    - dynamically generated list of all included Makefile*
    ALL.Makefiles   - static list of all source Makefile* of the project
    ALL.test.TYP    - list of all targets from Makefile.TYP aka Makefile.*
    ALL.tests       - list of all targets for testing
    ALL.tests.log   - list of all targets for tests writing to logfiles

The variables  ALL.tests  and  ALL.tests.log  are generated in  t/Makefile
from the corresponding  ALL.test.TYP  in each  t/Makefile.TYP , where  TYP
is  cmd, cgi, opt, etc.

SEE L</O-Saft:Makefile Includes>  also.


=head2 O-Saft:Makefile Targets

Naming conventions for targets:

    _test_name      - internal target, not intended for public use
    test.name       - public available targets use  .  (dot)  as separator
    test-name       - internal and pattern rule targets use  -  (dash)  as
                      separator
    test.name_arg   - some pattern rule targets use  _  to pass arguments
    test.name.log   - same as  test.name  but store results in logfile
    test%ext        - pattern rule used instead of explicit target rule to
                      allow spelling variants, like tst.ext or tst-ext
    testarg-TYP-*   - targets for testing tool arguments in Makefile.TYP
    testcmd-TYP-*   - targets for testing tool  commands in Makefile.TYP
                      "tool" may be any of those defined in macro  ALL.exe
                      see variable  ALL.exe  for defined "tool"s
    testarg-name%   - pattern rule which finally uses testarg-% target
    testcmd-name_%  - pattern rule which finally uses testcmd-% target

Examples:

    testcmd-cmd-+check_localhost    - test command +check of $(SRC.pl)
                                      with parameter localhost
                                      target can be found in Makefile.cmd

    testarg-dev-install-sh_--check  - test tool INSTALL.sh  with argument
                                      --check
                                      target can be found in Makefile.dev

Targets in the Makefile* are grouped, usually. Each group should be headed
by the help texts for the targets using  HELP-  variables (see below).

=head3 Get information about available targets

Following make commands can be used as starters to get a list of available
targets, their documentation, information about Makefiles and other help:

    make s-ALL.tests
    make help.test.all
    make help.test
    make help.test.targets
    make help.all
    make help.makefiles.doc
    make targets | grep ^test


=head2 O-Saft:Makefile HELP Texts

For extracting  information from the Makefile*,  i.e variables and targets
and their definitions, following special naming syntax is used:

* All texts for documentation are stored in variables prefixed  HELP-

* Anything following the prefix  HELP-  is the name of an existing target.
  Example:   HELP-doc   = contains the description of the target  doc

* Variable names with prefix  HELP-_  are treated as header texts, usually
  heading a group of targets.
  Example:   HELP-_help = ____ targets for help about Makefile _

* The variable with the prefix  HELP. for example  HELP.help,  is used for
  additional documentation; as the variable often contains multiline texts
  each line must be terminated with  $(_NL)\  which will be evaluated when
  the variable is used. It is good practice to start each line with  \# .

All variable names used for help texts use  - (dash)  instead of  . (dot).
This simplifies matching the names, as the dash is not a meta character in
RegEx and so must not be escaped. The  HELP.typ  variable is special as it
uses . as separator). It defines the help text for Makefile.typ itself and
must not be matched when extracting the other  HELP-*  variables.

Example:

    HELP-_cgi0      = _______________________________ some targets _
    HELP-help       = print overview of all targets
    HELP-doc        = same as help, but evaluates variables
    HELP.typ        = $(_NL)\
    \# some additional text with more than one line $(_NL)\
    \# other line

These  variables (above) are used by the  help  and  doc  target. They are
printed as follows:

             #_______________________________ some targets _
    help     # print overview of all targets
    doc      # same as help, but evaluates variables

    # some additional text with more than one line
    # other line



=head1 GNU Make

Internal testing of all functionality of the project  is done using  make,
in paticular  GNU Make. In contrast to traditional make, GNU Make has more
features and behaves slightly different to traditional make.

=head2 GNU Make:Terms

Some words about the terms and words used in GNU Make in this project.

* macro  is a synonym for  variable  in makefiles, here the  term variable
  is prefered.

* rule  is used by GNU Make, here the term  target  is prefered.

* GNU Make uses  functions  for its own built-in functions.  When commands
  are grouped using the  'define'  directive (function), GNU Make uses the
  term  "user defined functions". Here the term macro is used for that.

* GNU Make uses  prerequisites  when targets depend on something, here the
  term dependencies is used.

* GNU Make distinguishes the terms:   explicit rules,  implicit rules  and
  static pattern rules. For simplicity, target is used when explicit rules
  are meant, and  pattern rule  is used for  static pattern rule .

* GNU Make refers to the commands executed in a target as  recipe.

* GNU Make refers sometimes to targets as  goals (i.e. .DEFAULT_GOAL).

* GNU Make uses different terms for the same thing:

** "recursively expanded variables", "recursive assignment", "deferred
   definition"

** "simply expanded variables", "simple assignment", "immediate definition"

** "immediately expanded variables", "immediate assignment", "immediate
   definition"

=head3 GNU Make:Terms Comparsion

   # GNU Make Terms           |  Terms used in our Makefile*
   #--------------------------+-----------------------------------------
    macro                     |  variable
    user defined functions    |  macro
    explicit rule             |  target
    static pattern rule       |  pattern rule
    recipe                    |  commands
    deferred definition       |  deferred variable (or simply variable)
    immediate definition      |  static variable
    implicit variables        |  (not used)
   #--------------------------+-----------------------------------------


=head2 GNU Make:macros

* macro  is a synonym for  variable  in GNU Make makefiles.

* macro definitions in makefiles must not be sequential! Exceptions are
  immediate definitions.

* $$ avoids evaluating  $ (the variable) when reading the makefile, but it
  is evaluated when the corresponding target is executed.

* deferred  definition using    =   - variable expanded when used.

* conditional definition using ?=   - variable expanded when not defined.

* immediate definition using   :=   - variable expanded when defined.

* immediate definition using  ::=   - variable expanded when defined.

* immediate definition using :::=   - expanded when defined and used.

Note that  :=  (traditional GNU Make) is equivalent to  ::=  (POSIX). Only
:=  is used in our Makefile*.

:::=  is available since GNU Make 4.4, it is not used in our Makefile*.


=head2 GNU Make:include

GNU Make's include directive  does not understand variables, the used path
must be verbatim. Multiple makefiles are used to keep make's functionality
(targets) maintainable. Beside  Makefile  they are all named  Makefile.TYP
where  TYP  describes the content, somehow. I. g. it should be possible to
use each of these Makefile* by its own, like:

    make -f Makefile.TYP target

GNU Make's include functionality, in particular when including  files from
sub-directories, is difficult to use. Hence following trick is used:

* sub-directories contains a symbolic link to . (itself)

* Makefile*  always include other files with relative paths

Example:

    ./t/ (directory)  contains:  t -> .
    ./t/Makefile.cgi  contains:  include t/Makefile

This avoids sophistcated syntax in the files itself, like:

    ifeq (t,$(findstring t,$(PWD)))
        TEST.dir = .
        # if called inside t directory,  TEST.dir  must be redifined
    endif

GNU Make also cannot manage recursive includes of the same file. This must
be checked before including. The private  _SID.*  variable is used,  which
is set in all Makefile*. Example:

    ifeq (,$(_SID.test))
        -include t/Makefile
    endif

It is silently ignored if the file required by the  -include  directive is
missing.


=head2 GNU Make:important variables

Remember important variables:

    $(MAKE)         - the make command itself, in sub-make with additional
                      arguments/options (see make's documentation)
    $(MAKE_COMMAND) - private variable for the make command, without other
                      arguments/options as in $(MAKE)
                      SEE L</GNU Make:MAKE vs. MAKE_COMMAND>
    $(MFLAGS)       - contains all passed arguments/options to make
    $(MAKEFLAGS)    - same as $(MFLAGS) but omitts leading  -  character
    $(MAKECMDGOALS) - name of the target to be satisfied
    $(MAKEFILE)     - name of the target to be satisfied
    $(MAKEFILES)    - environment variable containing makefiles to be read
    $(MAKEFILE_LIST)- included Makefiles in the order they have been read

For details use:

    make help.test.make
    make help.test.makevars
    make testcmd-test.internal


=head2 GNU Make:automatic variables

Note that variable definitions in makefiles must not be sequential!

Remember GNU Make's automatic variables:

    $@    - target (file name)
    $*    - matching files of the rule, the stem of the pattern rule
    $+    - all dependencies of the target
    $-    - ??
    $^    - all dependencies of the target (without duplicates)
    $<    - first dependency of the target
    $?    - dependencies newer than the target
    $|    - "order-only" dependencies
    $*    - matching files of the rule
    $%    - target (archive) member name (rarely used)

Use of $$ avoids evaluating $ .

Keep in mind that GNU Make sets $* depending on the rule definition.  For
example $* should contain  dir/foo  in a rule  dir/foo.%  or to the files
matching that rule. For compatibility with traditional make, $* is set to
the %-part of the rule, example: $* contains  bar  if  dir/foo.%  is used
as  dir/foo.bar . We expect and use the traditional behaviour.


=head2 GNU Make:pattern-specific variables

Processing pattern-specific variables changed in gmake, I guess with 3.81.
Makefile* in this project rely on the behaviour of  gmake 3.81  and newer,
which applies all pattern-specific variables from all matching patterns.

If interested in the difference, read on.

Example (pre 3.81):

    VAR = default
    foo: VAR = foo
    bar: VAR = bar
    foo:
        @echo foo uses    VAR='$(VAR)'
    bar:
        @echo bar uses    VAR='$(VAR)'
    foobar:
        @echo foobar uses VAR='$(VAR)'
    other:
        @echo other uses  VAR='$(VAR)'


When calling these targets (foo, bar, foobar, other) the results are:

    foo uses    VAR='foo'
    bar uses    VAR='bar'
    foobar uses VAR='foo'
    other uses  VAR='default'

In contrast, gmake 3.81 and newer return following results:

    foo uses    VAR='default foo'
    bar uses    VAR='default bar'
    foobar uses VAR='default foo bar'
    other uses  VAR='default'

Note that the modern behaviour - applying all pattern-specific variables -
has a big performance penulty if many such variables are used. This should
not be the case in our Makefile* .


=head2 GNU Make:.SECONDEXPANSION

GNU Make's variables can be used as target, in the rules commands and also
as dependency. When used as dependency, it must be a file (or directory).

When a dependency to  another target is defined in a variable,  GNU Make's
"Secondary Expansion" must be enabled using the special target:

    .SECONDEXPANSION:

and the dependency have to be written as "escaped" variable, like:

    other = other-target
    other-target:
            do-somthing
    target: $$(other)

If the used make does not support  .SECONDEXPANSION: , the targets must be
rewritten with the real target name instead of the escaped variable.


=head2 GNU Make:Pattern Rule

GNU Make's >3.81 documentation states that the first matching pattern rule
will be used and others are not executed. First means: the first appearing
rule in the Makefile. On some systems the last defined  pattern rule  will
be executed, unfortunately.
This behaviour inhibits that  the sequence of rules  can be used to ensure
the execution of a special rule.
As workaround a more specific pattern rule is defined in such cases.


=head2 GNU Make:MAKE vs. MAKE_COMMAND

Traditionally $(MAKE) is used for the make command itself. For convenience
t/Makefile.inc  redefines  MAKE  to contain  -f Makefile  .

When  $(MAKE)  is used in documentation (variables or texts),  make should
be printed, usually. It is recommended to use  $(MAKE_COMMAND)  there.

When using  $(MAKE)  is used in quoted texts, for example:  echo "$(MAKE)"
GNU Make behaves strange and evaluates the line before printing).


=head2 GNU Make:Dragons

Sometimes GNU Make behaves strange when a literal $ character must be used
in the value of a variable. The usual way is to double it like:

    TEST.var := awk '/match/{ $$1 = "matched"; }'

If it does not work proper, it mainly renders to the empty string when the
variable is used.

Currently (2023) no workaround is known. Try to avoid $ then.


=head1 O-Saft Makefile Annotations

As in the source code of the project,  some descriptions in Makefile* also
need to be available on more than one place.  Such texts can be referenced
to using the "SEE <Annotation>" syntax in the Makefile*. These annotations
are described here, this file, one sub-section for each annotation.


=head2 Make:target name

For better readability, "speaking names"  should be used for pattern rules
and targets. It also allows to use the special pattern rule test.pattern-%
to execute a group of similar targets.


=head2 Make:target name prefix

A  unique name prefix  for targets and pattern rules should be used in all
Makefile.* to distinguish similar names. It also allows to use the pattern
rule  test.pattern-%  to execute a group of similar targets.

Following variable should then be set only for these targets, like:

    testcmd-TEMPL%:     EXE.pl      = ../program-for.TEMPL
    testcmd-TEMPL%:     TEST.init   = +quit


=head2 Make:target matching

For collecting all targets defined in a Makefile.*, following $(shell awk)
is used:

    $(shell awk -F% '($$1 ~ /^target-/){arr[$$1]=1}$(_EXE.print_arr_END.awk)'\
        $(_MYSELF.some-type))

(where  target-  is an example target name, and _EXE.print_arr_END.awk is
the awk code to print the defined array  arr[]).

Target names may occour as following constructs:

    static-target:
    pattern-rule-%:
    pattern-%-rule:
    static-target:    VAR = value
    pattern-rule-%:   VAR = value

The result should contain real (static) targets only, no pattern rules.
Duplicate target names should also be avoided.

Using awk satisfies both requirements. Matching targets is as simple as:

    /^target-%/{next}              # skips pattern rules
    /^target-[^%]*:/               # matches static targets
    /^target-[^%]*:/{arr[$$1]=1}   # stores target name in an array

awk's array  arr[]  now contains all target names.  Duplicates are ignored
because the already existing  arr[target]  is overwritten. Finally we just
need to print all array elements:

    END { for (idx in arr) { print idx } }

Matching targets needs to be done individually in each Makefile*, printing
the array is always the same. Hence the code for awk's "END{}"  can be put
in a make variable also.


=head2 Make:target generation

For testing single arguments out of a list with the same target,  a target
for for each argument is required. There're still some pattern rules which
do this, but they need to be called with the proper value of the pattern.
That's why we need a single target for each argument.

The first goal to do this is to write each of these unique targets without
commands (recipe). When called, they finally match a proper  pattern rule.
Example:

    testarg-%:
            some command here
    testarg-tst-tool--arg1:
    testarg-tst-tool--arg2:

As a naming scheme for target names is used which includes the tool's name
and the most important argument,  elongate target names  would be created.
There are also many targets then, which just differ in the  last part, the
argument.

Therefor, GNU Make provides "user defined functions" which we call macros.
They are mainly defined in Makefile.gen.

=head3 Synopsis

General macros (functions):

    $(call GEN.targets,testcmd,TYP,TOOL,VAR-name,TEST.args,TEST.init)
    $(call GEN.targets,testcmd,TYP,TOOL,VAR-name,TEST.init,TEST.args)

Wrapper macros (functions) calling the general macro:

    $(call GEN.targets-args,testarg,TYP,TOOL,VAR-name)
    $(call GEN.targets-init,testarg,TYP,TOOL,VAR-name)
    $(call GEN.targets-args,testcmd,TYP,TOOL,VAR-name)
    $(call GEN.targets-init,testcmd,TYP,TOOL,VAR-name)

=head3 Description

The goal of the functions is to generate all targets for a  specific tool.
Any tool may be called with its own arguments. Therefore, each argument to
be tested with a tool, requires its own target. Also, each target  must be
added to the corresponding / well-known variable, for example: ALL.* etc..
Finally a target -pattern rule- is generated, which groups the targets for
this tool. Please see below for L</Examples>.

For these targets, the variables  EXE.pl,  TEST.init  and  TEST.args  must
be defined properly.  In most cases, only one of  TEST.init  or  TEST.args
is needed. The other one is set empty.  It avoids inheritance of its value
from other matching targets. Abstract example:

    testarg-TYP-TOOL_%:    EXE.pl    = ../TOOL
    testarg-TYP-TOOL_%:    TEST.init = 
    testarg-TYP-TOOL-arg:  TEST.args = some-arg

As no commands  are defined for the targets,  they (above example) finally
As no commands are defined for the targets, they finally match the generic
target  testarg-% . Currently supported pattern rules in t/Makefile are:

    testarg-%  and  testcmd-%

This still allows to use special or additional settings for the  generated
targets. Such settings must be done explicitly in the calling Makefile.* .
Example:

    testarg-TYP-TOOL-arg:  TEST.init += other-arg

=head3 Target generation function

The target names follow a strict syntax, see L</O-Saft:Makefile Targets>.
In short, the naming scheme is:

    testarg-TYP-TOOL-OPTIONS_ARGUMENT

where TYP is the Makefile's type, TOOL is the tool to be executed, OPTIONS
are the used options for the tool and  ARGUMENT is a paramter to the tool.
The prefix of the target name,  testarg in above example,  can be specifid
too.  Note that a corresponding pattern rule must exist with this pattern.
Currentls there are:  testarg-%  testcmd-% .

To build the target name,  the prefix, TYP and TOOL  must be passed to the
functions. They are passed verbatim. The last parameter passed is the name
of the variable which contains a list of values to be used as ARGUMENT.

Because there are a some (GNU Make) restrictions for allowed characters in
target names, some characters of the values need to be substituted.  These
charcters are in particular / : and =  . Means that ARGUMENT can be like:

    --option=value

Note that the tools are called in the test directory, ./t usually, they're
and should not be found via  $PATH . So the value assigned to EXE.pl  must
be prefixed with ../ .

All generated targets are also added to the variable  ALL.test.TYP .

SEE L</O-Saft:Makefile Variable, Macro names>  also.
SEE L</O-Saft:Makefile Variable, Macro names>  also.

=head3 Target function variants

Depending on the purpose of the tests, setting the variables TEST.init and
TEST.args should be swapped.  Therefore, the function provides  parameters
for them. Swapping the variables has no impact on the commands executed by
the target, beside the order of its arguments.  For Example, this could be
used to generate the same command-line just differing in the last argument
of the executed command (may produce a more pretty output).

Additionally 2 simple wrapper functions for both variants are provided.

=head3 Examples

=over

=item Generate targets for various options

    TOOL       = path/tool
    LIST.tool  = --opt=val  --arg
    $(call GEN.targets-args,testarg,typ,$(TOOL),LIST.tool)

This generates following targets and variables:

    testarg.typ.path-tool_--opt-val: TEST.args = --option1
    testarg.typ.path-tool_--arg:     TEST.args = --option1
    testarg.typ.path-tool_%:         TEST.init =
    testarg.typ.path-tool_%:         EXE.pl    = ../path/tool
    ALL.testarg.typ.path-tool = testarg.typ.path-tool_--option1
                                testarg.typ.path-tool_--arg
    ALL.testarg.typ           = $(ALL.testarg.typ.path-tool)

=item Generate targets for various options

    $(call GEN.targets-init,testarg,typ,$(TOOL),LIST.tool)

TODO ... to be completed ...

=back


=head2 Make:variables and quotes

Values of variables in GNU Make's makefiles follow some strange rules:

* anything right of leftmost # character is a comment and ignored

* anything right of leftmost = character is part of the value

* single quotes, double quotes and \ character have no special meaning

* single quotes, double quotes and \ become meta characters depending on
  how the variable is used, in particular used with or without quotes

* newlines in a variable are not preserved when the variable is used

For most common usage of variables, these rules are less important. But if
the variable contains descriptive texts, some care needs to be taken. This
description is about defining and using such variables with random texts.

In general it is not necessary to use quotes for variable values. However,
reading the values would be easyer and syntax highlighting in some editors
more accurate using quotes.

Note that quotes in the definition of the variable are part of its value.

It is more a personal preference if quotes for variable definitions should
be used or not. The decision here is to not use quotes for definition, but
use (double) quotes for variable's usage.  This also has the benefit, that
a variable is identifiable as "descriptive text" when used.

Keep in mind, that newlines to be printed must be explicitly  written in a
variable's value, $(_NL) is used for that.

GNU Make's define  directive, which would avoid the use of  $(_NL), is not
used to set variables. May change in future ...


=head2 Make:macros

This is about our macros, which are "user defined functions" in GNU Make.

Some notes about oddities with 'define', 'foreach', 'call', 'eval':

=over

=item using 'foreach' function in general

To enforces execution of $(foreach ..) in the macro, macro definitions are
defined inside  'ifndef' .. 'endif'  scope.

=item 'foreach', 'call' function

While the 'foreach' function allows seperating its parameters with spaces,
parameters for 'call' and 'subst' must be used without spaces.

=item using variablas in macros

Variables n macros can be set directly by using:

    _macro-var=value

or

    $(eval _macro-var=value)

Unfortunatelly a simple  'undefine _macro-var'  does not always work. Then
'$(eval undefine _macro-var)'  must be used. It is difficult to debug such
variables, best is to use our target like:

    make help.test.makevars | grep _macro-var

=back


=head2 Make:defines with commands (recipes)

If defines containg lists of commands are used to be executed in a target,
following rules need to be observed:

* using shell's test commands inside  GNU Make's makefiles  is tricky,  as
  single quotes instead of double quote must be used  for test -n '$var' .


=head2 Make:--ignore-output

Some values of keys are different by nature for each call of  o-saft.pl .
To avoid diffs when testing with  *.log  targets, output of such keys must
be ignored for  all targets with  +info ,  +check  or any other  combining
commands (like  +hsts). Output such keys can be ignored using  o-saft.pl's
option  --ignore-output=  (alias  --no-out=). Alias  --no-out=  is used to
keep the command-line shorter.

The variable  _ignore-output  (computed from _ignore-output-keys) contains
these keys (commands). This variable should be used whenever such commands
are tested.

Unfortunately  this  results in  untested commands,  those defined  in the
variable  _ignore-output-keys . An additional target  should exist to test
these commands also.

SEE L</Make:OSAFT_MAKE>, L</Make:EXE.log-filter>, L</GNU Make:Dragons> also.


=head2 Make:--dry-run

When make is called with the  -n  (--dry-run) option,  make usually simply
prints the commands to be executed instead of executing them. If a command
redirects its output to a file, the file will not be generated. But if the
command is  $(MAKE)  make will be called recursively and redirected to the
specified file. This generated file then doesn't contain expected content.
Hence the generation of the file should be avoided.

The recursive make command should be printed instead of being executed.
GNU Make has following documented recipe for this:

    ifeq (n,$(findstring n,$(MAKEFLAGS)))
        @echo "$(MAKE) $(MAKEFLAGS) $* > $@"
    else
        @$(MAKE) $(MAKEFLAGS) $* > $@
    endif

Unfortunately this solution has the drawback that it

  * depends on the version of GNU Make (may work or not)
  * is not compatible with other make

Another possibility is to use shell's if-then-else syntax for the target's
commands. Beside the ugly definition of a shell inline script, this script
then also acts as one command in the target which makes the output hard to
read (by humans).

Hence following simplified  if-then-else  construct is used:

    @expr "$(MAKEFLAGS)" : n >/dev/null \
            && echo "$(MAKE) $(MFLAGS) -s $* > $@ 2>&1" \
            ||       $(MAKE) $(MFLAGS) -s $* > $@ 2>&1

Note that  $(MAKEFLAGS)  may look like:  nrR --no-print-directory


=head2 Make:Perl::Analyzer

For generating documentation of the own Perl modules and a calling tree of
them, perl-analyzer is used. The tools require the Perl modules  JSON  and
Text::MicroTemplate  (beside some mor commonly installed Perl modules).

See also: INSTALL.sh --checkdev


=head2 Make:Profiling

Profiling is mainly done with Perl's built-in functionality: perldebug.

There are also targets which require the Perl modules  Devel::DProf and/or
Devel::NYTProf  to do the profiling.

See also: INSTALL.sh --checkdev

=head3 Perl packages

  * debian: libdevel-trace-perl libdebug-trace-perl
  * debian: libdevel-dprof-perl libdevel-nytprof-perl
  * debian: libjson-perl libtext-microtemplate-perl
  * debian: libgraph-easy-perl  libgraph-easy-as-svg-perl
  * debian: libgraphviz-perl    libgetopt-simple-perl


=head2 Make:profile.sub

For building the function calling tree,  perldebug (PERLDB_OPTS)  is used.
The results can be stored in a file, see  LineInfo=  options.
Unfortunately perldebug writes output to the device directly  (for example
/dev/stdout).  It is not possible to merge output from the executed script
with that of perldebug. Following options are not helpful:

  * pager=|cat
  * LineInfo=/dev/stdout
  * noTTY=1


=head2 Make:profile.sub*_%

It should be simply possible to extend the  pattern rules  with additional
arguments. For example:  profile.sub.args   and  profile.sub.args_+cn .
These arguments are extracted in the  pattern rule  itself. This avoids to
define more  conditional rules  for each  pattern rule to set the variable
$(TEST.args)  with the arguments.

The simplest way to split the arguments would be:

  @$(eval _args = $(shell echo "$*" | tr '_' ' '))

but the last part of the target name needs to be removed, hence following
is used for splitting:

  @$(eval _args = $(shell echo "$*" | awk -F_ '{i=1;while(i<NF){i++;print $$i}}'))

To use the default setting if no arguments are given, following is used:

  @$(eval TEST.args = $(shell [ -n "$(_args)" ] && echo $(_args) || echo $(TEST.args) ))

=head3 Make:profile.sub_%.log

Rules writing to logfiles cannot be named like  profile.sub.%.log  if they
should contain additional arguments like  profile.sub.%_+cn.log,  but must
be named  profile.sub.%.log_+cn  otherwise the  .log  extension becomes an
argument (see description how to split arguments above).


=head2 Make:profile.sub% target rule

This rule matches all targets, e.g.  profile.sub.entry, profile.sub.args .
It should also be possible to pass additional arguments to  $(EXE.pl). The
default argument is defined in  $(TEST.args). Other arguments to be passed
are simply added to the target, separated by  _  for example:

    profile.sub.args_+cn_--noheader

This is actually a shortcut for calling:

    profile.sub.args TEST.args="+cn --noheader"

The conditional rules split the additional arguments as follows:

* split the rule's automatic variable  $*  by  _

* the first value of a splitted argument is ignored,  as it is part of the
  target name

=head3 Example for splitting: profile.sub.args_+cn_--noheader

    $*       : args_+cn_--noheader
    splitted : args +cn --noheader
    TEST.args:      +cn --noheader

This is done using (see above):

  awk -F_ '{i=1;while(i<NF){i++;print $$i}}'

=head3 Limitations

* arguments with  _  itself cannot be used

* when  target names  with or without additional arguments are used,  GNU
  Make's syntax requires separate conditional rules, hence there're:

        profile.sub.args:
        profile.sub.args_%:

* miss-spelled  targets  fall back to the corresponding  basic conditional
  rules; for example  profile.sub.args-+cn  calls  profile.sub.args

* if called from within  $(TEST.dir),  $(EXE.pl)  should be set on make
  call like:

       make profile.sub.args-+cn EXE.pl=../yeast.pl


=head2 Make:podchecker

podchecker  complains if a  =head*  section has no text like:

       *** WARNING: empty section in previous paragraph at line ...

for example if it's followed by the next  =head*  section. Such situations
are intended when aliases are described, for example:

       =head3 +sts

       =head3 +hsts

podchecker's warning can be avoided, when there is no empty line after the
first  =head*  line. On the other hand,  POD syntax requires an empty line
after each  =head*  line. This is considered a bug in podchecker.
This applies to Pod::Checker <= 1.73  (as podchecker is just a wrapper for
Pod::Checker).


=head2 Make:OSAFT_MAKE

Some data printed by the tools are  random,  means that they are different
for each call of the tool, for example date and time.
If these tools are called by make and the results are written to a logfile
which will be compared with a previous logfile, these files always differ.
To avoid this difference (because of random text) a dummy constant text is
written if our special environment variable  OSAFT_MAKE  exists.
This environment variable should be set in Makefile*.

A generic text is available as  STR_MAKEVAL  (see osaft.pm). In some cases
(i.e. for date and time) the string is prepared individually. This effects
mainly strings printed in debugging or trace mode.
To avoid dependencies to be fulfilled at runtime, STR_MAKEVAL  is not used
in all tools but hardcoded there again. This may/should change in future.

SEE L<Make:--ignore-output>, L</Make:EXE.log-filter>, L</GNU Make:Dragons> also.


=head2 Make:generating help

Text to be printed for the  help*  targets are mainly hardcoded in various
HELP-*  variables which will be extracted from the corresponding Makefile*
as needed.  The advantage of this method is, that the texts are printed in
the sequence they are defined in the Makefile* . The disadvantage is, that
other external tools are necessary.

In some Makefile* the help texts can be generated dynamically using make's
internal functions like $(foreach ...) . It can generate HELP-* variables,
which then can be accessed from within make but not be extracted. Example:

    $(foreach arg,$(LIST.program),$(eval  \
        HELP-test.$(arg) = targets for testing something) )

the  HELP.doc  variable is used therefore.  The texts will be  added to it
dynamically, example:

    $(foreach arg, $(LIST.program), $(eval \
        HELP.doc +=\btest.$(arg)\t\# targets for testing something)\n )

Unfortunately, this adds additional leading spaces to each generated line.


=head2 Make:generating help files

Many help and documentation texts are provided in files or are generated.

For generating documentation in various formats, like POD, nroff, Makefile
targets are used. Take care, that some of the tools for generation produce
random output like  current date and time.  This behaviour is harmless for
normal use, but may cause difficulties when comparing output  as in  *.log
targets.

SEE L</GNU Make:Dragons>, L</Make:EXE.log-filter> also.


=head2 Make:EXE.log-filter

To avoid diffs when testing with  *.log  targets, output can be piped to a
filter which normalises the random text. In t/Makefile following variables
are provided for the filter program:

    EXE.log-filterarg := cat
    EXE.log-filtercmd := cat

The default filter program is  cat , which does nothing.

The generalised use is like:

    testcmd-some.target.log:
        do-somthing | $(EXE.log-filtercmd) > $@

To activate the filter, the variable  EXE.log-filterarg  EXE.log-filtercmd
must be set. For example like:

    EXE.log-filterarg := sed -ne 's/random text/OSAFT_MAKE/'

This is usually done by defining the variable depending on a unique target
like:

    testcmd-some.target.log: EXE.log-filterarg := sed -ne 's/random text/OSAFT_MAKE/'

SEE L</Make:OSAFT_MAKE>, L</Make:--ignore-output>, L</GNU Make:Dragons> also.


=head2 EXE.pl:--trace-CLI

Most calls of  o-saft.pl  are done with the  --trace-CLI  option, which is
configured in  TEST.init  variable.  This enforces printing of the command
line at beginning of output.

For some generated output, this additional 1st line may break its intended
usage. This applies only if the output is written to a file for later use.
However, make's test targets are not intended to produce "working" output,
but logfiles to identify differences.


=head2 Troubleshooting

To parametrise targets in various ways,  they make heavy use of variables.
Some of the variables are set conditionally for targets and pattern rules.

If things go wrong, or results are unexpected, following steps may help to
narrow down the problem source:

* use same target with  -v  appended:  test-v  instead of  test
  the executed target would then be printed; see Makefile for examples and
  how to set the  O-TRACE.target  variable; please not that for  *.log
  targets  O-TRACE.target.log  can also be used

* use -n option for make

* get list of targets, for example executed targets for  test.cgi :

    make e-ALL.test.cgi

* get list of all targets (and variables),  which match the specified one;
  for example to get list of  test.cgi  targets:

    make t-test.cgi

* use -d option for make

=cut
